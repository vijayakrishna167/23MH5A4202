# My HTTP URL Shortener Microservice

Hey there! Welcome to the repository for my HTTP URL Shortener Microservice. This project was built to offer a robust and reliable solution for shortening long URLs, complete with some basic analytics to track link usage. My goal was to create a clean, efficient API that's ready for a production environment, all while keeping things scalable and easy to maintain.

## What This Service Does (and What It Doesn't)

Here's a quick rundown of the core features and some ground rules I followed during development:

*   **Logging is Key**: I've implemented a comprehensive logging system using Winston. This means all important events and errors are recorded to `combined.log`, and you won't see any messy console logs clogging up your terminal. This is super important for monitoring in a real-world setup.
*   **One Service, Many Jobs**: This project is designed as a single microservice that handles all the URL shortening and statistics endpoints.
*   **Authentication? Not Here!**: For the scope of this project, I'm assuming that users accessing the API are already authorized. So, there are no user registration or login mechanisms built into this service.
*   **Short Links Are Unique**: Every short link generated by this service is guaranteed to be globally unique. No clashes, no confusion!
*   **Default Expiry**: If you don't specify how long a short link should last, it'll automatically expire after 30 minutes. You can always set a custom duration in minutes if you need to.
*   **Your Custom Shortcodes**: Want a specific word for your short link? You can request a custom shortcode. The service will check if it's available and use it if it's unique.

## Why I Built It This Way: Key Design Decisions

I made several conscious choices during development to ensure this service is solid and effective:

1.  **Node.js & Express.js for Speed**: I picked Node.js because it's fantastic for handling lots of requests quickly, especially for I/O-heavy tasks like URL shortening. Express.js is its perfect partner â€“ it's lightweight and gives me exactly what I need to build a clean RESTful API without a lot of extra baggage.
2.  **MongoDB & Mongoose for Flexibility**: For the database, MongoDB was a clear winner. It's a NoSQL database, which means it's super flexible with its schema. This was perfect for storing click data, which can vary. Mongoose then steps in to make interacting with MongoDB a breeze, adding some helpful structure and validation.
3.  **Winston for Serious Logging**: I chose Winston because it's a powerful logging library. By directing all logs to a file (`combined.log`), I ensure that there's a clear, persistent record of everything happening, which is essential for debugging and monitoring in production. Console logging was explicitly turned off to keep things clean.
4.  **`.env` for Secure Configs**: Sensitive information, like the MongoDB connection string (`MONGO_URI`), isn't hardcoded. Instead, it's pulled from environment variables using `dotenv`. This is a best practice for security and makes it simple to deploy the service across different environments (development, staging, production) without changing any code.
5.  **`shortid` for Snappy Shortcodes**: I needed a way to generate unique, easy-to-read short links. `shortid` does exactly that, efficiently creating unique, URL-friendly IDs without me having to reinvent the wheel.
6.  **Modular Code Structure**: You'll find the code neatly organized into `models`, `config`, `middleware`, and `routes` folders. This separation of concerns makes the codebase much easier to read, understand, test, and maintain. It's like having well-labeled drawers for all your tools.
7.  **Robust Error Handling**: I've put a lot of effort into making sure the API handles errors gracefully. You'll see consistent `try...catch` blocks and meaningful HTTP status codes (like 400 for bad requests, 404 if something's not found, 409 for conflicts, and 500 for server-side issues) with clear JSON messages. This makes the API predictable and easier for other services to interact with.

## The Tech Stack

Just to reiterate, here are the main technologies powering this service and why they were chosen:

*   **Node.js**: Fantastic for handling many concurrent connections thanks to its non-blocking I/O.
*   **Express.js**: A minimalist, flexible web framework that helps set up robust API endpoints quickly.
*   **MongoDB**: A document database offering flexibility and scalability, especially useful for dynamic data like click analytics.
*   **Mongoose**: An Object Data Modeling (ODM) library that streamlines how Node.js applications interact with MongoDB, providing schema validation and a more structured approach.
*   **Winston**: For professional-grade logging, ensuring all application events are captured reliably to a file.
*   **Shortid**: Generates concise, unique, and URL-safe identifiers.
*   **Body-parser**: Handles parsing incoming request bodies, making it easy to work with JSON payloads.
*   **Dotenv**: Essential for securely managing environment-specific configurations.

## How the Data Looks: The `Url` Model

This is the blueprint for how each shortened URL is stored in our MongoDB database:

```javascript
// models/Url.js
const mongoose = require('mongoose');

const UrlSchema = new mongoose.Schema({
  shortCode: {
    type: String,
    required: true,
    unique: true,
  },
  longUrl: {
    type: String,
    required: true,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  expiresAt: {
    type: Date,
  },
  clicks: [
    {
      timestamp: {
        type: Date,
        default: Date.now,
      },
      referrer: {
        type: String,
      },
      ip: {
        type: String,
      }
    }
  ],
});

module.exports = mongoose.model('Url', UrlSchema);
```

*   **`shortCode`**: The unique, short identifier (e.g., `abcd1`). It's required and must be unique.
*   **`longUrl`**: The original, full URL that gets shortened. Also required.
*   **`createdAt`**: The exact date and time when the short URL was created. Automatically set when a new entry is made.
*   **`expiresAt`**: The date and time when the short URL will stop working. If this field is empty, the URL never expires.
*   **`clicks`**: An array that keeps a record of every single time someone clicks on the short link. Each entry in this array includes:
    *   **`timestamp`**: When the click happened.
    *   **`referrer`**: Where the user came from (e.g., Google, another website, or 'direct' if they typed it in).
    *   **`ip`**: The IP address of the person who clicked. This can be used for coarse geographical location tracking.

## Let's Talk APIs: Endpoints and How to Use Them

Assuming your service is up and running on `http://localhost:5000`, here's how you interact with it:

### 1. Create a Short URL

This is how you get a long URL shortened.

*   **Method**: `POST`
*   **Endpoint**: `http://localhost:5000/shorturls`

*   **What to Send (JSON in the request body)**:
    ```json
    {
        "url": "https://www.example.com/this-is-a-super-duper-long-url-that-i-really-really-need-to-shorten-for-my-project",
        "validity": 30,    // Optional: How many minutes this link should be active. Defaults to 30 if you don't send it.
        "shortcode": "mycustomlink" // Optional: Want a specific shortcode? Send it here. If it's unique, it's yours!
    }
    ```

*   **What You'll Get Back (Successful Response - Status: 201 Created)**:
    ```json
    {
        "shortLink": "http://localhost:5000/mycustomlink",
        "expiry": "2025-01-01T00:30:00Z" // The exact time your link will expire
    }
    ```

*   **Things That Can Go Wrong (Error Cases)**:
    *   **400 Bad Request**: `{"error": "Invalid URL format"}` - Happens if the `url` you sent isn't a valid URL.
    *   **409 Conflict**: `{"error": "Custom shortcode already in use"}` - If you tried to set a `shortcode` (like `mycustomlink`), but someone else already took it.
    *   **500 Internal Server Error**: `Server error` - Something unexpected went wrong on my end. Check the `combined.log` for details!

### 2. Redirect to the Original URL & Record the Click

This is the magic! When someone visits your short link, this endpoint redirects them.

*   **Method**: `GET`
*   **Endpoint**: `http://localhost:5000/:shortCode` (e.g., `http://localhost:5000/mycustomlink`)

*   **What Happens**: If the `shortCode` exists and hasn't expired, the browser will be automatically sent to the original long URL. Plus, every time this happens, I record a click event (timestamp, where they came from, and their IP address).

*   **Things That Can Go Wrong (Error Cases)**:
    *   **404 Not Found**:
        *   `No short URL found` - If that `shortCode` simply doesn't exist.
        *   `Short URL has expired` - The link existed, but it's now past its expiry date.
    *   **500 Internal Server Error**: `Server error` - Another unexpected issue on the server side. Again, `combined.log` is your friend here.

### 3. Get Short URL Statistics

Curious about how your short links are performing? This endpoint gives you the stats.

*   **Method**: `GET`
*   **Endpoint**: `http://localhost:5000/shorturls/:shortCode` (e.g., `http://localhost:5000/shorturls/mycustomlink`)

*   **What You'll Get Back (Successful Response - Status: 200 OK)**:
    ```json
    {
        "totalClicks": 15, // The total number of times your short link has been clicked
        "originalUrl": "https://en.wikipedia.org/wiki/Microservice",
        "creationDate": "2024-06-25T10:00:00Z",
        "expiryDate": "2025-01-01T00:30:00Z", // Or "Never expires" if you didn't set one
        "clickData": [
            {
                "timestamp": "2024-06-25T10:05:15Z",
                "referrer": "https://www.social-media.com/post", // Where the click came from
                "ip": "192.168.1.10" // The IP address of the clicker
            },
            {
                "timestamp": "2024-06-25T11:20:30Z",
                "referrer": "direct", // Typed directly into the browser
                "ip": "192.168.1.11"
            }
            // ... and so on for all clicks!
        ]
    }
    ```

*   **Things That Can Go Wrong (Error Cases)**:
    *   **404 Not Found**: `No short URL found for statistics` - If you're asking for stats on a `shortCode` that just doesn't exist.
    *   **500 Internal Server Error**: `Server error` - Another server hiccup. Check the `combined.log` for details!

## My Assumptions (The Fine Print)

To keep the project focused, I made a few assumptions:

*   **Authentication is External**: I'm assuming that any authentication or authorization of users is handled *before* requests hit this microservice. It doesn't have its own login system.
*   **MongoDB is Ready**: This service expects a MongoDB instance to be up and running and accessible via the `MONGO_URI` you provide in your `.env` file.
*   **IPs for Rough Location**: While I collect IP addresses, converting them into precise geographical locations would require an additional service or library, which is outside the scope of this project. The IP is there for a coarse indication.
*   **Referrer Header's Reliability**: I'm relying on the `Referrer` HTTP header to track where clicks originate. Sometimes this header might not be present (e.g., for direct entries), in which case it defaults to 'direct'.
*   **Shortcode Collisions are Rare**: While the `shortid` library is excellent for generating unique IDs, theoretically, with extremely high concurrent requests, a collision *could* occur. However, it's highly improbable for typical use cases, and the custom shortcode check already handles explicit conflicts.

## Keeping It Tidy and Ready for Growth: Scalability & Maintainability

I've designed this service with the future in mind:

*   **Modular Design**: The organized folder structure (models, config, middleware, routes) isn't just for looks. It makes the code super easy to read, find specific pieces of functionality, and simplifies adding new features or fixing bugs down the line. It's a maintainer's dream!
*   **Stateless by Nature**: The microservice itself doesn't hold onto user-specific data; all that lives in MongoDB. This means you can easily scale it horizontally by spinning up more instances behind a load balancer without any headaches.
*   **MongoDB's Scalability**: MongoDB is built for handling large amounts of data and traffic. Its ability to shard (distribute data across multiple servers) means that as your URL and click data grow, your database can grow with it.
*   **Centralized Logging**: All those structured logs going into `combined.log` are gold. They make it easy to set up centralized logging tools for monitoring the application's health, quickly debugging issues, and understanding user behavior.
*   **Environment Variables for Easy Deployment**: By keeping sensitive configurations in `.env` files, deploying this service to different environments (like a test server vs. a live production server) is a breeze. No code changes needed!
*   **Solid Error Handling**: The consistent and informative error responses are a huge win. They provide clear feedback to anyone using the API and make it much simpler for developers to pinpoint and fix problems.
*   **Clear Dependencies**: The `package.json` file clearly lists all project dependencies, making it straightforward to set up the development environment and ensure everyone's working with the same versions of libraries.

## Getting Started: Setup and Running

Ready to get this microservice up and running?

### Prerequisites

Before you begin, make sure you have these installed:

*   **Node.js**: I recommend using an LTS (Long Term Support) version.
*   **npm**: Node Package Manager, which usually comes bundled with Node.js.
*   **MongoDB**: You'll need a running instance of MongoDB. This could be a local installation (Community Server) or a cloud-based solution like MongoDB Atlas.

### Installation Steps

1.  **Get the Code**: If you cloned this repository, great! Otherwise, just make sure you have all the project files.
2.  **Navigate**: Open your terminal or command prompt and go to the project's root directory:
    ```bash
    cd /path/to/your/RestAPI
    ```
3.  **Install Dependencies**: This command will fetch all the necessary libraries for the project:
    ```bash
    npm install
    ```

### Configuration: Your `.env` File

This is a crucial step for connecting to your database:

1.  In the root of your project directory, create a new file named `.env`.
2.  Inside this `.env` file, add your MongoDB connection URI. **Remember to replace `YOUR_MONGODB_CONNECTION_STRING` with your actual connection string!**
    ```
    MONGO_URI=mongodb+srv://vijayakrishnaalla:avk1234@lib.ugfjwys.mongodb.net/?retryWrites=true&w=majority&appName=LIB
    ```
    *   **Tip for local development**: If you're running MongoDB on your machine, a common local URI looks like: `mongodb://127.0.0.1:27017/urlshortener`.

### Firing Up the Application

1.  **MongoDB Check**: Double-check that your MongoDB instance is running and accessible using the `MONGO_URI` you just set up.
2.  **Start the Server**: From your project's root directory in the terminal, run:
    ```bash
    node index.js
    ```
    You should see confirmation messages like "MongoDB Connected..." and "Server running on port 5000" (or whatever port is configured) in your terminal. All ongoing logs will now be saved to `combined.log`.

## How to Test It Out!

You can use tools like Postman, Insomnia, or even simple `curl` commands to test the API. Just make sure the server is running first!

### 1. Creating a Short URL

*   **Action**: Send a `POST` request.
*   **To**: `http://localhost:5000/shorturls`
*   **Headers**: Make sure to set `Content-Type: application/json`.
*   **Body (JSON)**: Here are some examples of what you can send:
    *   **Auto-generate a shortcode, default 30-min expiry:**
        ```json
        {
            "url": "https://www.google.com/a-really-interesting-and-unique-search-query-for-the-internet"
        }
        ```
    *   **Your own custom shortcode, 60-min expiry:**
        ```json
        {
            "url": "https://en.wikipedia.org/wiki/Microservices_architecture",
            "validity": 60,
            "shortcode": "my-cool-microservice"
        }
        ```

### 2. Visiting (Redirecting) Your Short URL

*   **Action**: Just visit the URL!
*   **To**: `http://localhost:5000/YOUR_SHORT_CODE` (e.g., if you created `my-cool-microservice`, go to `http://localhost:5000/my-cool-microservice`)
*   **How to test**: Simply open your web browser and paste the full short link into the address bar. You should be magically redirected to the original long URL. Every time you do this, a click will be recorded!

### 3. Checking Your Short URL's Stats

*   **Action**: Send a `GET` request.
*   **To**: `http://localhost:5000/shorturls/YOUR_SHORT_CODE` (e.g., `http://localhost:5000/shorturls/my-cool-microservice`)
*   **How to test**: Use Postman or `curl` for this. You'll get back a JSON object with all the juicy details about your short link, including total clicks, original URL, creation/expiry dates, and a breakdown of each click.


Don't forget to keep an eye on your `combined.log` file for all the behind-the-scenes application logs! It's a great way to see what's happening. 